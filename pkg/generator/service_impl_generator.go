package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// ServiceImplGenerator 领域服务实现生成器
//
// 生成嵌入 BaseService[T] 的具体服务实现，包含标记驱动的校验逻辑：
//   - required：非空校验
//   - unique：唯一性校验
//   - ref：外键存在性校验
//   - enum：枚举值校验
//
// 生成文件：domain/service/impl/{AggregateName}ServiceImpl.go
type ServiceImplGenerator struct{}

// NewServiceImplGenerator 创建领域服务实现生成器
func NewServiceImplGenerator() *ServiceImplGenerator {
	return &ServiceImplGenerator{}
}

// Generate 为聚合根生成领域服务实现
func (g *ServiceImplGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 获取绝对路径
	absOutputDir, _ := filepath.Abs(outputDir)

	// 创建输出目录：service/impl
	implDir := filepath.Join(absOutputDir, "service", "impl")
	if err := os.MkdirAll(implDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 计算各个依赖的 import 路径
	imports := &serviceImplImports{
		model:      agg.ImportPath,
		repository: calculateImportPath(agg.ModuleName, agg.ModuleRoot, filepath.Join(absOutputDir, "repository")),
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sServiceImpl.go", agg.Name)
	filePath := filepath.Join(implDir, fileName)

	// 生成代码
	code := g.generateCode(agg, imports)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// serviceImplImports 领域服务实现的 import 路径
type serviceImplImports struct {
	model      string
	repository string
}

// refFieldInfo 外键字段信息
type refFieldInfo struct {
	FieldName     string // 字段名，如 UserID
	RefAggregate  string // 引用的聚合根名，如 User
	RepoFieldName string // 仓储字段名，如 userRepo
}

// generateCode 生成领域服务实现代码
func (g *ServiceImplGenerator) generateCode(agg *metadata.AggregateMetadata, imports *serviceImplImports) string {
	var sb strings.Builder

	// 收集外键字段信息
	refs := g.collectRefFields(agg)

	// 检查需要哪些包
	needErrors := false // 有 required 字段时需要
	needFmt := false    // 有 unique 或 enum 或 ref 字段时需要
	for _, field := range agg.Fields {
		if field.Annotations.IsRequired {
			needErrors = true
		}
		if field.Annotations.IsUnique || len(field.Annotations.EnumValues) > 0 || field.Annotations.IsRef {
			needFmt = true
		}
	}

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package impl\n\n")

	// 导入（使用动态计算的 import 路径）
	sb.WriteString("import (\n")
	sb.WriteString("\t\"context\"\n")
	if needErrors {
		sb.WriteString("\t\"errors\"\n")
	}
	if needFmt {
		sb.WriteString("\t\"fmt\"\n")
	}
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.model))
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.repository))
	sb.WriteString("\t\"soliton/pkg/framework\"\n")
	sb.WriteString(")\n\n")

	// 结构体定义
	sb.WriteString(fmt.Sprintf("// %sServiceImpl %s 领域服务实现\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("type %sServiceImpl struct {\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\tframework.BaseService[*%s.%s]\n", agg.PackageName, agg.Name))
	sb.WriteString(fmt.Sprintf("\trepository repository.%sRepository\n", agg.Name))
	// 添加外键仓储依赖
	for _, ref := range refs {
		sb.WriteString(fmt.Sprintf("\t%s repository.%sRepository\n", ref.RepoFieldName, ref.RefAggregate))
	}
	sb.WriteString("}\n\n")

	// 构造函数
	sb.WriteString(g.generateConstructorWithRefs(agg, refs))
	sb.WriteString("\n")

	// 重写 Add 方法（含校验）
	sb.WriteString(g.generateAddMethodWithRef(agg, refs))
	sb.WriteString("\n")

	// 重写 Update 方法（含校验）
	sb.WriteString(g.generateUpdateMethodWithRef(agg, refs))
	sb.WriteString("\n")

	// 生成校验方法
	sb.WriteString(g.generateValidationMethods(agg))

	// 生成外键校验方法
	sb.WriteString(g.generateRefValidation(agg, refs))

	return sb.String()
}

// generateConstructor 生成构造函数（无外键依赖）
func (g *ServiceImplGenerator) generateConstructor(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// New%sService 创建 %s 领域服务实例\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("func New%sService(repo repository.%sRepository) *%sServiceImpl {\n",
		agg.Name, agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("\treturn &%sServiceImpl{\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\t\tBaseService: *framework.NewBaseService[*%s.%s](repo),\n", agg.PackageName, agg.Name))
	sb.WriteString("\t\trepository:  repo,\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateConstructorWithRefs 生成构造函数（带外键仓储依赖）
func (g *ServiceImplGenerator) generateConstructorWithRefs(agg *metadata.AggregateMetadata, refs []*refFieldInfo) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// New%sService 创建 %s 领域服务实例\n", agg.Name, agg.Name))

	// 构造函数参数
	params := []string{fmt.Sprintf("repo repository.%sRepository", agg.Name)}
	for _, ref := range refs {
		params = append(params, fmt.Sprintf("%s repository.%sRepository", ref.RepoFieldName, ref.RefAggregate))
	}

	sb.WriteString(fmt.Sprintf("func New%sService(\n", agg.Name))
	for i, param := range params {
		if i < len(params)-1 {
			sb.WriteString(fmt.Sprintf("\t%s,\n", param))
		} else {
			sb.WriteString(fmt.Sprintf("\t%s,\n", param))
		}
	}
	sb.WriteString(fmt.Sprintf(") *%sServiceImpl {\n", agg.Name))

	sb.WriteString(fmt.Sprintf("\treturn &%sServiceImpl{\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\t\tBaseService: *framework.NewBaseService[*%s.%s](repo),\n", agg.PackageName, agg.Name))
	sb.WriteString("\t\trepository:  repo,\n")
	for _, ref := range refs {
		sb.WriteString(fmt.Sprintf("\t\t%s: %s,\n", ref.RepoFieldName, ref.RepoFieldName))
	}
	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateAddMethodWithRef 生成 Add 方法（含外键校验）
func (g *ServiceImplGenerator) generateAddMethodWithRef(agg *metadata.AggregateMetadata, refs []*refFieldInfo) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// Add 添加实体（含校验）\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) Add(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	// 生成校验逻辑
	sb.WriteString("\t// 必填字段校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateRequired(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 唯一性校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateUnique(ctx, entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 枚举值校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateEnum(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	// 外键存在性校验
	sb.WriteString("\t// 外键存在性校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateRef(ctx, entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 调用仓储层保存\n")
	sb.WriteString(fmt.Sprintf("\treturn %s.repository.Add(ctx, entity)\n", receiver))
	sb.WriteString("}\n")

	return sb.String()
}

// generateUpdateMethodWithRef 生成 Update 方法（含外键校验）
func (g *ServiceImplGenerator) generateUpdateMethodWithRef(agg *metadata.AggregateMetadata, refs []*refFieldInfo) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// Update 更新实体（含校验）\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) Update(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	sb.WriteString("\t// 必填字段校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateRequired(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 唯一性校验（排除自己）\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateUniqueExcludeSelf(ctx, entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 枚举值校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateEnum(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	// 外键存在性校验
	sb.WriteString("\t// 外键存在性校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateRef(ctx, entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 调用仓储层更新\n")
	sb.WriteString(fmt.Sprintf("\treturn %s.repository.Update(ctx, entity)\n", receiver))
	sb.WriteString("}\n")

	return sb.String()
}

// generateAddMethod 生成 Add 方法（含校验）
func (g *ServiceImplGenerator) generateAddMethod(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// Add 添加实体（含校验）\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) Add(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	// 生成校验逻辑
	sb.WriteString("\t// 必填字段校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateRequired(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 唯一性校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateUnique(ctx, entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 枚举值校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateEnum(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 调用仓储层保存\n")
	sb.WriteString(fmt.Sprintf("\treturn %s.repository.Add(ctx, entity)\n", receiver))
	sb.WriteString("}\n")

	return sb.String()
}

// generateUpdateMethod 生成 Update 方法（含校验）
func (g *ServiceImplGenerator) generateUpdateMethod(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// Update 更新实体（含校验）\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) Update(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	sb.WriteString("\t// 必填字段校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateRequired(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 唯一性校验（排除自己）\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateUniqueExcludeSelf(ctx, entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 枚举值校验\n")
	sb.WriteString(fmt.Sprintf("\tif err := %s.validateEnum(entity); err != nil {\n", receiver))
	sb.WriteString("\t\treturn err\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\t// 调用仓储层更新\n")
	sb.WriteString(fmt.Sprintf("\treturn %s.repository.Update(ctx, entity)\n", receiver))
	sb.WriteString("}\n")

	return sb.String()
}

// generateValidationMethods 生成校验方法
func (g *ServiceImplGenerator) generateValidationMethods(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	// 1. 必填字段校验
	sb.WriteString(fmt.Sprintf("// validateRequired 必填字段校验\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) validateRequired(entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	hasRequired := false
	for _, field := range agg.Fields {
		if field.Annotations.IsRequired {
			hasRequired = true
			// 根据类型生成不同的校验逻辑
			if field.Type == "string" {
				sb.WriteString(fmt.Sprintf("\tif entity.%s == \"\" {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\treturn errors.New(\"%s 不能为空\")\n", field.Name))
				sb.WriteString("\t}\n")
			} else if !field.IsPointer {
				sb.WriteString(fmt.Sprintf("\tif entity.%s == 0 {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\treturn errors.New(\"%s 不能为空\")\n", field.Name))
				sb.WriteString("\t}\n")
			}
		}
	}

	if !hasRequired {
		sb.WriteString("\t// 无必填字段\n")
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	// 2. 唯一性校验
	sb.WriteString(fmt.Sprintf("// validateUnique 唯一性校验\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) validateUnique(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	hasUnique := false
	firstUnique := true
	for _, field := range agg.Fields {
		if field.Annotations.IsUnique {
			hasUnique = true
			sb.WriteString(fmt.Sprintf("\t// %s 唯一性校验\n", field.Name))
			// 第一个用 :=，后续用 =
			if firstUnique {
				sb.WriteString(fmt.Sprintf("\texisting, err := %s.repository.GetBy%s(ctx, entity.%s)\n",
					receiver, field.Name, field.Name))
				firstUnique = false
			} else {
				sb.WriteString(fmt.Sprintf("\texisting, err = %s.repository.GetBy%s(ctx, entity.%s)\n",
					receiver, field.Name, field.Name))
			}
			sb.WriteString("\tif err == nil && existing != nil {\n")
			sb.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s 已存在: %%v\", entity.%s)\n",
				field.Name, field.Name))
			sb.WriteString("\t}\n\n")
		}
	}

	if !hasUnique {
		sb.WriteString("\t// 无唯一字段\n")
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	// 3. 唯一性校验（排除自己）
	sb.WriteString(fmt.Sprintf("// validateUniqueExcludeSelf 唯一性校验（排除自己）\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) validateUniqueExcludeSelf(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	if hasUnique {
		firstUnique = true
		for _, field := range agg.Fields {
			if field.Annotations.IsUnique {
				sb.WriteString(fmt.Sprintf("\t// %s 唯一性校验\n", field.Name))
				// 第一个用 :=，后续用 =
				if firstUnique {
					sb.WriteString(fmt.Sprintf("\texisting, err := %s.repository.GetBy%s(ctx, entity.%s)\n",
						receiver, field.Name, field.Name))
					firstUnique = false
				} else {
					sb.WriteString(fmt.Sprintf("\texisting, err = %s.repository.GetBy%s(ctx, entity.%s)\n",
						receiver, field.Name, field.Name))
				}
				sb.WriteString("\tif err == nil && existing != nil && existing.GetID() != entity.GetID() {\n")
				sb.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s 已存在: %%v\", entity.%s)\n",
					field.Name, field.Name))
				sb.WriteString("\t}\n\n")
			}
		}
	} else {
		sb.WriteString("\t// 无唯一字段\n")
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	// 4. 枚举值校验
	sb.WriteString(fmt.Sprintf("// validateEnum 枚举值校验\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) validateEnum(entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	hasEnum := false
	for _, field := range agg.Fields {
		if len(field.Annotations.EnumValues) > 0 {
			hasEnum = true
			sb.WriteString(fmt.Sprintf("\t// %s 枚举校验\n", field.Name))
			sb.WriteString(fmt.Sprintf("\tvalid%s := map[string]bool{\n", field.Name))
			for _, value := range field.Annotations.EnumValues {
				sb.WriteString(fmt.Sprintf("\t\t\"%s\": true,\n", value))
			}
			sb.WriteString("\t}\n")
			sb.WriteString(fmt.Sprintf("\tif !valid%s[entity.%s] {\n", field.Name, field.Name))
			sb.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"%s 值无效: %%s\", entity.%s)\n",
				field.Name, field.Name))
			sb.WriteString("\t}\n\n")
		}
	}

	if !hasEnum {
		sb.WriteString("\t// 无枚举字段\n")
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	return sb.String()
}

// collectRefFields 收集所有外键字段信息
func (g *ServiceImplGenerator) collectRefFields(agg *metadata.AggregateMetadata) []*refFieldInfo {
	var refs []*refFieldInfo
	seen := make(map[string]bool) // 避免重复

	for _, field := range agg.Fields {
		if field.Annotations.IsRef {
			// 从字段名推断聚合根名称
			// 例如：UserID -> User, OrderID -> Order
			refAggregate := g.extractRefAggregateName(field.Name)
			if refAggregate != "" && !seen[refAggregate] {
				seen[refAggregate] = true
				refs = append(refs, &refFieldInfo{
					FieldName:     field.Name,
					RefAggregate:  refAggregate,
					RepoFieldName: toLowerFirst(refAggregate) + "Repo",
				})
			}
		}
	}

	return refs
}

// extractRefAggregateName 从字段名提取引用的聚合根名称
// UserID -> User, OrderID -> Order, CreatorID -> Creator
func (g *ServiceImplGenerator) extractRefAggregateName(fieldName string) string {
	// 如果以 ID 结尾，去掉 ID
	if strings.HasSuffix(fieldName, "ID") && len(fieldName) > 2 {
		return fieldName[:len(fieldName)-2]
	}
	// 如果以 Id 结尾，去掉 Id
	if strings.HasSuffix(fieldName, "Id") && len(fieldName) > 2 {
		return fieldName[:len(fieldName)-2]
	}
	return ""
}

// generateRefValidation 生成外键存在性校验方法
func (g *ServiceImplGenerator) generateRefValidation(agg *metadata.AggregateMetadata, refs []*refFieldInfo) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// validateRef 外键存在性校验\n"))
	sb.WriteString(fmt.Sprintf("func (%s *%sServiceImpl) validateRef(ctx context.Context, entity *%s.%s) error {\n",
		receiver, agg.Name, agg.PackageName, agg.Name))

	if len(refs) == 0 {
		sb.WriteString("\t// 无外键字段\n")
		sb.WriteString("\treturn nil\n")
		sb.WriteString("}\n\n")
		return sb.String()
	}

	for _, ref := range refs {
		// 获取该外键字段的所有字段（可能有多个字段引用同一个聚合根）
		for _, field := range agg.Fields {
			if field.Annotations.IsRef && g.extractRefAggregateName(field.Name) == ref.RefAggregate {
				sb.WriteString(fmt.Sprintf("\t// %s 外键存在性校验\n", field.Name))
				sb.WriteString(fmt.Sprintf("\tif entity.%s != 0 {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\texists, err := %s.%s.Exists(ctx, entity.%s)\n",
					receiver, ref.RepoFieldName, field.Name))
				sb.WriteString("\t\tif err != nil {\n")
				sb.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"校验 %s 失败: %%w\", err)\n", field.Name))
				sb.WriteString("\t\t}\n")
				sb.WriteString("\t\tif !exists {\n")
				sb.WriteString(fmt.Sprintf("\t\t\treturn fmt.Errorf(\"%s 不存在: %%d\", entity.%s)\n",
					ref.RefAggregate, field.Name))
				sb.WriteString("\t\t}\n")
				sb.WriteString("\t}\n\n")
			}
		}
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	return sb.String()
}
