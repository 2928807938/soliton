// Code generated by soliton. DO NOT EDIT.

package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// QueryFieldGenerator 查询字段生成器
//
// 生成类似 GORM Gen 风格的类型安全查询字段，避免硬编码 SQL 列名。
// 每个字段都有对应的查询方法如 Eq(), Neq(), Gt(), In() 等。
//
// 生成文件：infrastructure/persistence/query/{AggregateName}Fields.go
type QueryFieldGenerator struct{}

// NewQueryFieldGenerator 创建查询字段生成器
func NewQueryFieldGenerator() *QueryFieldGenerator {
	return &QueryFieldGenerator{}
}

// Generate 为聚合根生成查询字段
func (g *QueryFieldGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 创建输出目录（infrastructure 与 domain 平级）
	queryDir := filepath.Join(filepath.Dir(outputDir), "infrastructure", "query")
	if err := os.MkdirAll(queryDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 生成字段文件
	fileName := fmt.Sprintf("%sFields.go", agg.Name)
	filePath := filepath.Join(queryDir, fileName)

	code := g.generateFieldsCode(agg)

	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// GenerateFieldTypes 生成通用的字段类型定义（只需生成一次）
func (g *QueryFieldGenerator) GenerateFieldTypes(outputDir string) error {
	queryDir := filepath.Join(filepath.Dir(outputDir), "infrastructure", "query")
	if err := os.MkdirAll(queryDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	filePath := filepath.Join(queryDir, "field_types.go")
	code := g.generateFieldTypesCode()

	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// generateFieldTypesCode 生成字段类型定义代码
func (g *QueryFieldGenerator) generateFieldTypesCode() string {
	return `// Code generated by soliton. DO NOT EDIT.

package query

import (
	"fmt"
	"strings"
)

// Condition 查询条件接口
type Condition interface {
	Build() (string, []interface{})
}

// condition 条件实现
type condition struct {
	column string
	op     string
	value  interface{}
	values []interface{}
}

func (c *condition) Build() (string, []interface{}) {
	switch c.op {
	case "IN", "NOT IN":
		placeholders := make([]string, len(c.values))
		for i := range c.values {
			placeholders[i] = "?"
		}
		return fmt.Sprintf("%s %s (%s)", c.column, c.op, strings.Join(placeholders, ", ")), c.values
	case "IS NULL", "IS NOT NULL":
		return fmt.Sprintf("%s %s", c.column, c.op), nil
	case "BETWEEN":
		return fmt.Sprintf("%s BETWEEN ? AND ?", c.column), c.values
	case "LIKE", "NOT LIKE":
		return fmt.Sprintf("%s %s ?", c.column, c.op), []interface{}{c.value}
	default:
		return fmt.Sprintf("%s %s ?", c.column, c.op), []interface{}{c.value}
	}
}

// Int64Field int64 类型字段
type Int64Field struct {
	column string
}

func NewInt64Field(column string) Int64Field {
	return Int64Field{column: column}
}

func (f Int64Field) Column() string { return f.column }

func (f Int64Field) Eq(value int64) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f Int64Field) Neq(value int64) Condition {
	return &condition{column: f.column, op: "<>", value: value}
}

func (f Int64Field) Gt(value int64) Condition {
	return &condition{column: f.column, op: ">", value: value}
}

func (f Int64Field) Gte(value int64) Condition {
	return &condition{column: f.column, op: ">=", value: value}
}

func (f Int64Field) Lt(value int64) Condition {
	return &condition{column: f.column, op: "<", value: value}
}

func (f Int64Field) Lte(value int64) Condition {
	return &condition{column: f.column, op: "<=", value: value}
}

func (f Int64Field) In(values ...int64) Condition {
	v := make([]interface{}, len(values))
	for i, val := range values {
		v[i] = val
	}
	return &condition{column: f.column, op: "IN", values: v}
}

func (f Int64Field) NotIn(values ...int64) Condition {
	v := make([]interface{}, len(values))
	for i, val := range values {
		v[i] = val
	}
	return &condition{column: f.column, op: "NOT IN", values: v}
}

func (f Int64Field) Between(min, max int64) Condition {
	return &condition{column: f.column, op: "BETWEEN", values: []interface{}{min, max}}
}

func (f Int64Field) IsNull() Condition {
	return &condition{column: f.column, op: "IS NULL"}
}

func (f Int64Field) IsNotNull() Condition {
	return &condition{column: f.column, op: "IS NOT NULL"}
}

// Int32Field int32 类型字段
type Int32Field struct {
	column string
}

func NewInt32Field(column string) Int32Field {
	return Int32Field{column: column}
}

func (f Int32Field) Column() string { return f.column }

func (f Int32Field) Eq(value int32) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f Int32Field) Neq(value int32) Condition {
	return &condition{column: f.column, op: "<>", value: value}
}

func (f Int32Field) Gt(value int32) Condition {
	return &condition{column: f.column, op: ">", value: value}
}

func (f Int32Field) Gte(value int32) Condition {
	return &condition{column: f.column, op: ">=", value: value}
}

func (f Int32Field) Lt(value int32) Condition {
	return &condition{column: f.column, op: "<", value: value}
}

func (f Int32Field) Lte(value int32) Condition {
	return &condition{column: f.column, op: "<=", value: value}
}

func (f Int32Field) In(values ...int32) Condition {
	v := make([]interface{}, len(values))
	for i, val := range values {
		v[i] = val
	}
	return &condition{column: f.column, op: "IN", values: v}
}

func (f Int32Field) NotIn(values ...int32) Condition {
	v := make([]interface{}, len(values))
	for i, val := range values {
		v[i] = val
	}
	return &condition{column: f.column, op: "NOT IN", values: v}
}

func (f Int32Field) Between(min, max int32) Condition {
	return &condition{column: f.column, op: "BETWEEN", values: []interface{}{min, max}}
}

func (f Int32Field) IsNull() Condition {
	return &condition{column: f.column, op: "IS NULL"}
}

func (f Int32Field) IsNotNull() Condition {
	return &condition{column: f.column, op: "IS NOT NULL"}
}

// StringField string 类型字段
type StringField struct {
	column string
}

func NewStringField(column string) StringField {
	return StringField{column: column}
}

func (f StringField) Column() string { return f.column }

func (f StringField) Eq(value string) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f StringField) Neq(value string) Condition {
	return &condition{column: f.column, op: "<>", value: value}
}

func (f StringField) Like(value string) Condition {
	return &condition{column: f.column, op: "LIKE", value: value}
}

func (f StringField) NotLike(value string) Condition {
	return &condition{column: f.column, op: "NOT LIKE", value: value}
}

func (f StringField) In(values ...string) Condition {
	v := make([]interface{}, len(values))
	for i, val := range values {
		v[i] = val
	}
	return &condition{column: f.column, op: "IN", values: v}
}

func (f StringField) NotIn(values ...string) Condition {
	v := make([]interface{}, len(values))
	for i, val := range values {
		v[i] = val
	}
	return &condition{column: f.column, op: "NOT IN", values: v}
}

func (f StringField) IsNull() Condition {
	return &condition{column: f.column, op: "IS NULL"}
}

func (f StringField) IsNotNull() Condition {
	return &condition{column: f.column, op: "IS NOT NULL"}
}

// Float64Field float64 类型字段
type Float64Field struct {
	column string
}

func NewFloat64Field(column string) Float64Field {
	return Float64Field{column: column}
}

func (f Float64Field) Column() string { return f.column }

func (f Float64Field) Eq(value float64) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f Float64Field) Neq(value float64) Condition {
	return &condition{column: f.column, op: "<>", value: value}
}

func (f Float64Field) Gt(value float64) Condition {
	return &condition{column: f.column, op: ">", value: value}
}

func (f Float64Field) Gte(value float64) Condition {
	return &condition{column: f.column, op: ">=", value: value}
}

func (f Float64Field) Lt(value float64) Condition {
	return &condition{column: f.column, op: "<", value: value}
}

func (f Float64Field) Lte(value float64) Condition {
	return &condition{column: f.column, op: "<=", value: value}
}

func (f Float64Field) Between(min, max float64) Condition {
	return &condition{column: f.column, op: "BETWEEN", values: []interface{}{min, max}}
}

func (f Float64Field) IsNull() Condition {
	return &condition{column: f.column, op: "IS NULL"}
}

func (f Float64Field) IsNotNull() Condition {
	return &condition{column: f.column, op: "IS NOT NULL"}
}

// BoolField bool 类型字段
type BoolField struct {
	column string
}

func NewBoolField(column string) BoolField {
	return BoolField{column: column}
}

func (f BoolField) Column() string { return f.column }

func (f BoolField) Eq(value bool) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f BoolField) Is(value bool) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f BoolField) IsNull() Condition {
	return &condition{column: f.column, op: "IS NULL"}
}

func (f BoolField) IsNotNull() Condition {
	return &condition{column: f.column, op: "IS NOT NULL"}
}

// TimeField time.Time 类型字段
type TimeField struct {
	column string
}

func NewTimeField(column string) TimeField {
	return TimeField{column: column}
}

func (f TimeField) Column() string { return f.column }

func (f TimeField) Eq(value interface{}) Condition {
	return &condition{column: f.column, op: "=", value: value}
}

func (f TimeField) Neq(value interface{}) Condition {
	return &condition{column: f.column, op: "<>", value: value}
}

func (f TimeField) Gt(value interface{}) Condition {
	return &condition{column: f.column, op: ">", value: value}
}

func (f TimeField) Gte(value interface{}) Condition {
	return &condition{column: f.column, op: ">=", value: value}
}

func (f TimeField) Lt(value interface{}) Condition {
	return &condition{column: f.column, op: "<", value: value}
}

func (f TimeField) Lte(value interface{}) Condition {
	return &condition{column: f.column, op: "<=", value: value}
}

func (f TimeField) Between(min, max interface{}) Condition {
	return &condition{column: f.column, op: "BETWEEN", values: []interface{}{min, max}}
}

func (f TimeField) IsNull() Condition {
	return &condition{column: f.column, op: "IS NULL"}
}

func (f TimeField) IsNotNull() Condition {
	return &condition{column: f.column, op: "IS NOT NULL"}
}

// Where 辅助函数：将多个条件组合为 GORM 可用的格式
func Where(db interface{ Where(query interface{}, args ...interface{}) interface{} }, conds ...Condition) interface{} {
	result := db
	for _, cond := range conds {
		sql, args := cond.Build()
		result = result.Where(sql, args...)
	}
	return result
}
`
}

// generateFieldsCode 生成实体的查询字段代码
func (g *QueryFieldGenerator) generateFieldsCode(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package query\n\n")

	// 生成字段结构体
	structName := toLowerFirst(agg.Name) + "Fields"

	sb.WriteString(fmt.Sprintf("// %s %s 的查询字段\n", structName, agg.Name))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	for _, field := range agg.Fields {
		// 跳过关联实体字段
		if field.Annotations.IsEntity {
			continue
		}

		fieldType := g.getFieldType(field.Type)
		sb.WriteString(fmt.Sprintf("\t%s %s\n", field.Name, fieldType))
	}

	sb.WriteString("}\n\n")

	// 生成全局变量
	sb.WriteString(fmt.Sprintf("// %s %s 查询字段\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("var %s = %s{\n", agg.Name, structName))

	for _, field := range agg.Fields {
		// 跳过关联实体字段
		if field.Annotations.IsEntity {
			continue
		}

		constructor := g.getFieldConstructor(field.Type)
		sb.WriteString(fmt.Sprintf("\t%s: %s(\"%s\"),\n", field.Name, constructor, field.DBTag))
	}

	sb.WriteString("}\n")

	return sb.String()
}

// getFieldType 根据 Go 类型返回对应的查询字段类型
func (g *QueryFieldGenerator) getFieldType(goType string) string {
	// 处理指针类型
	goType = strings.TrimPrefix(goType, "*")

	switch goType {
	case "int64":
		return "Int64Field"
	case "int32", "int":
		return "Int32Field"
	case "string":
		return "StringField"
	case "float64":
		return "Float64Field"
	case "float32":
		return "Float64Field"
	case "bool":
		return "BoolField"
	case "time.Time":
		return "TimeField"
	default:
		// 默认使用 StringField
		return "StringField"
	}
}

// getFieldConstructor 根据 Go 类型返回字段构造函数名
func (g *QueryFieldGenerator) getFieldConstructor(goType string) string {
	// 处理指针类型
	goType = strings.TrimPrefix(goType, "*")

	switch goType {
	case "int64":
		return "NewInt64Field"
	case "int32", "int":
		return "NewInt32Field"
	case "string":
		return "NewStringField"
	case "float64":
		return "NewFloat64Field"
	case "float32":
		return "NewFloat64Field"
	case "bool":
		return "NewBoolField"
	case "time.Time":
		return "NewTimeField"
	default:
		return "NewStringField"
	}
}
