package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
	"time"
)

// SQLGenerator SQL DDL 生成器
//
// 生成 MySQL 建表脚本，包含：
//   - 表结构定义
//   - 主键、唯一索引、普通索引
//   - 外键约束（可选）
//   - 多对多关联表
//
// 生成文件：sql/schema.sql
type SQLGenerator struct {
	registry *metadata.AggregateMetadataRegistry
}

// NewSQLGenerator 创建 SQL 生成器
func NewSQLGenerator(registry *metadata.AggregateMetadataRegistry) *SQLGenerator {
	return &SQLGenerator{
		registry: registry,
	}
}

// Generate 生成 SQL 建表脚本
func (g *SQLGenerator) Generate(outputDir string) error {
	// 创建输出目录
	sqlDir := filepath.Join(outputDir, "sql")
	if err := os.MkdirAll(sqlDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 生成文件路径
	filePath := filepath.Join(sqlDir, "schema.sql")

	// 生成 SQL 代码
	sql := g.generateSQL()

	// 写入文件
	if err := os.WriteFile(filePath, []byte(sql), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// generateSQL 生成完整的 SQL 脚本
func (g *SQLGenerator) generateSQL() string {
	var sb strings.Builder

	// 文件头
	sb.WriteString("-- Code generated by soliton. DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("-- Generated at: %s\n\n", time.Now().Format("2006-01-02 15:04:05")))
	sb.WriteString("-- Database: MySQL 5.7+\n")
	sb.WriteString("-- Charset: utf8mb4\n\n")

	// 设置字符集
	sb.WriteString("SET NAMES utf8mb4;\n")
	sb.WriteString("SET FOREIGN_KEY_CHECKS = 0;\n\n")

	// 生成聚合根表
	for _, agg := range g.registry.GetAll() {
		sb.WriteString(g.generateTable(agg))
		sb.WriteString("\n")
	}

	// 生成多对多关联表
	for _, table := range g.registry.GetManyToManyTables() {
		sb.WriteString(g.generateManyToManyTable(table))
		sb.WriteString("\n")
	}

	sb.WriteString("SET FOREIGN_KEY_CHECKS = 1;\n")

	return sb.String()
}

// generateTable 生成单个表的 DDL
func (g *SQLGenerator) generateTable(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	tableName := g.getTableName(agg.Name)

	sb.WriteString(fmt.Sprintf("-- ----------------------------\n"))
	sb.WriteString(fmt.Sprintf("-- Table structure for %s\n", tableName))
	sb.WriteString(fmt.Sprintf("-- ----------------------------\n"))
	sb.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n", tableName))
	sb.WriteString(fmt.Sprintf("CREATE TABLE `%s` (\n", tableName))

	// 生成列定义
	columns := []string{}

	// ID 字段（主键）
	if agg.IDField != nil {
		columns = append(columns, g.generateColumn(agg.IDField, true))
	}

	// 普通字段
	for _, field := range agg.Fields {
		// 跳过 ID 字段（已经处理）
		if agg.IDField != nil && field.Name == agg.IDField.Name {
			continue
		}

		// 跳过关联实体字段（不存储在数据库）
		if field.Annotations.IsEntity {
			continue
		}

		columns = append(columns, g.generateColumn(field, false))
	}

	// 主键定义
	if agg.IDField != nil {
		columns = append(columns, fmt.Sprintf("  PRIMARY KEY (`%s`)", g.getColumnName(agg.IDField.Name)))
	}

	// 唯一索引
	for _, field := range agg.Fields {
		if field.Annotations.IsUnique {
			indexName := fmt.Sprintf("uk_%s_%s", tableName, g.getColumnName(field.Name))
			columns = append(columns, fmt.Sprintf("  UNIQUE KEY `%s` (`%s`)", indexName, g.getColumnName(field.Name)))
		}
	}

	// 普通索引
	for _, field := range agg.Fields {
		if field.Annotations.IsIndex || field.Annotations.IsRef {
			indexName := fmt.Sprintf("idx_%s_%s", tableName, g.getColumnName(field.Name))
			columns = append(columns, fmt.Sprintf("  KEY `%s` (`%s`)", indexName, g.getColumnName(field.Name)))
		}
	}

	// DeletedAt 索引（用于软删除查询优化）
	if agg.BaseEntity.HasDeletedAt {
		indexName := fmt.Sprintf("idx_%s_deleted_at", tableName)
		columns = append(columns, fmt.Sprintf("  KEY `%s` (`deleted_at`)", indexName))
	}

	sb.WriteString(strings.Join(columns, ",\n"))
	sb.WriteString("\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci")
	sb.WriteString(fmt.Sprintf(" COMMENT='%s 表';\n", agg.Name))

	return sb.String()
}

// generateColumn 生成列定义
func (g *SQLGenerator) generateColumn(field *metadata.FieldMetadata, isPrimaryKey bool) string {
	columnName := g.getColumnName(field.Name)
	sqlType := g.mapGoTypeToSQL(field.Type, field.IsPointer)

	var parts []string
	parts = append(parts, fmt.Sprintf("  `%s`", columnName))
	parts = append(parts, sqlType)

	// NOT NULL 约束
	if !field.IsPointer && !isPrimaryKey {
		if field.Annotations.IsRequired || field.Type == "int64" || field.Type == "int" || field.Type == "float64" {
			parts = append(parts, "NOT NULL")
		}
	}

	// 默认值
	if field.IsPointer {
		parts = append(parts, "DEFAULT NULL")
	} else if field.Type == "string" && !isPrimaryKey {
		parts = append(parts, "DEFAULT ''")
	} else if (field.Type == "int64" || field.Type == "int" || field.Type == "float64") && !isPrimaryKey {
		parts = append(parts, "DEFAULT 0")
	}

	// 自增（仅主键）
	if isPrimaryKey && (field.Type == "int64" || field.Type == "int") {
		parts = append(parts, "AUTO_INCREMENT")
	}

	// 注释
	comment := field.Name
	if field.Annotations.IsUnique {
		comment += " (唯一)"
	}
	if field.Annotations.IsRequired {
		comment += " (必填)"
	}
	if field.Annotations.IsRef {
		comment += " (外键)"
	}
	parts = append(parts, fmt.Sprintf("COMMENT '%s'", comment))

	return strings.Join(parts, " ")
}

// generateManyToManyTable 生成多对多关联表
func (g *SQLGenerator) generateManyToManyTable(table *metadata.ManyToManyTableMetadata) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("-- ----------------------------\n"))
	sb.WriteString(fmt.Sprintf("-- Table structure for %s (多对多关联表)\n", table.TableName))
	sb.WriteString(fmt.Sprintf("-- ----------------------------\n"))
	sb.WriteString(fmt.Sprintf("DROP TABLE IF EXISTS `%s`;\n", table.TableName))
	sb.WriteString(fmt.Sprintf("CREATE TABLE `%s` (\n", table.TableName))

	columns := []string{
		"  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键'",
		fmt.Sprintf("  `%s` BIGINT NOT NULL COMMENT '%s ID'", table.LeftColumn, table.LeftAggregate),
		fmt.Sprintf("  `%s` BIGINT NOT NULL COMMENT '%s ID'", table.RightColumn, table.RightAggregate),
		"  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'",
		"  PRIMARY KEY (`id`)",
		fmt.Sprintf("  UNIQUE KEY `uk_%s_%s_%s` (`%s`, `%s`)", table.TableName, table.LeftColumn, table.RightColumn, table.LeftColumn, table.RightColumn),
		fmt.Sprintf("  KEY `idx_%s_%s` (`%s`)", table.TableName, table.LeftColumn, table.LeftColumn),
		fmt.Sprintf("  KEY `idx_%s_%s` (`%s`)", table.TableName, table.RightColumn, table.RightColumn),
	}

	sb.WriteString(strings.Join(columns, ",\n"))
	sb.WriteString("\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci")
	sb.WriteString(fmt.Sprintf(" COMMENT='%s 和 %s 关联表';\n", table.LeftAggregate, table.RightAggregate))

	return sb.String()
}

// mapGoTypeToSQL Go 类型映射到 MySQL 类型
func (g *SQLGenerator) mapGoTypeToSQL(goType string, isPointer bool) string {
	// 去除指针标记
	baseType := strings.TrimPrefix(goType, "*")

	switch baseType {
	case "int64":
		return "BIGINT"
	case "int", "int32":
		return "INT"
	case "int16":
		return "SMALLINT"
	case "int8":
		return "TINYINT"
	case "uint64":
		return "BIGINT UNSIGNED"
	case "uint", "uint32":
		return "INT UNSIGNED"
	case "uint16":
		return "SMALLINT UNSIGNED"
	case "uint8":
		return "TINYINT UNSIGNED"
	case "float64":
		return "DOUBLE"
	case "float32":
		return "FLOAT"
	case "bool":
		return "TINYINT(1)"
	case "string":
		return "VARCHAR(255)"
	case "time.Time":
		return "DATETIME"
	case "[]byte":
		return "BLOB"
	default:
		// 默认使用 TEXT 存储复杂类型（JSON）
		return "TEXT"
	}
}

// getTableName 获取表名（驼峰转下划线，复数形式）
func (g *SQLGenerator) getTableName(aggregateName string) string {
	// 驼峰转下划线
	tableName := g.camelToSnake(aggregateName)

	// 简单的复数规则
	if strings.HasSuffix(tableName, "s") {
		return tableName + "es"
	} else if strings.HasSuffix(tableName, "y") {
		return tableName[:len(tableName)-1] + "ies"
	} else {
		return tableName + "s"
	}
}

// getColumnName 获取列名（驼峰转下划线）
func (g *SQLGenerator) getColumnName(fieldName string) string {
	return g.camelToSnake(fieldName)
}

// camelToSnake 驼峰转下划线
// 示例：UserID -> user_id, OrderNo -> order_no, CreatedAt -> created_at
func (g *SQLGenerator) camelToSnake(s string) string {
	var result []rune
	runes := []rune(s)

	for i := 0; i < len(runes); i++ {
		r := runes[i]

		// 如果是大写字母
		if r >= 'A' && r <= 'Z' {
			// 不是第一个字符，且前一个不是大写，需要加下划线
			if i > 0 && runes[i-1] >= 'a' && runes[i-1] <= 'z' {
				result = append(result, '_')
			}
			// 如果后面还有字符，且后面是小写，也需要加下划线
			// 例如：UserID -> user_id（在 I 前加下划线）
			if i > 0 && i < len(runes)-1 && runes[i-1] >= 'A' && runes[i-1] <= 'Z' && runes[i+1] >= 'a' && runes[i+1] <= 'z' {
				result = append(result, '_')
			}
		}
		result = append(result, r)
	}

	return strings.ToLower(string(result))
}
