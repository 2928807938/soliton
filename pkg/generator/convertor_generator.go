package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// ConvertorGenerator 转换器生成器
//
// 生成领域对象和数据对象之间的双向转换器：
//   - ToDomain(do) -> domain：数据对象 → 领域对象
//   - ToData(domain) -> do：领域对象 → 数据对象
//
// 转换规则：
//  1. 简单类型：直接赋值
//  2. 值对象：根据策略展开或JSON反序列化
//  3. 关联实体：跳过，不转换（保持聚合边界）
//
// 生成文件：infrastructure/persistence/convertor/{AggregateName}Convertor.go
type ConvertorGenerator struct{}

// NewConvertorGenerator 创建转换器生成器
func NewConvertorGenerator() *ConvertorGenerator {
	return &ConvertorGenerator{}
}

// Generate 为聚合根生成转换器
func (g *ConvertorGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 获取绝对路径
	absOutputDir, _ := filepath.Abs(outputDir)
	parentDir := filepath.Dir(absOutputDir)

	// 创建输出目录（infrastructure 与 domain 平级）
	convertorDir := filepath.Join(parentDir, "infrastructure", "convertor")
	if err := os.MkdirAll(convertorDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 计算各个依赖的 import 路径
	imports := &convertorImports{
		model: agg.ImportPath,
		do:    calculateImportPath(agg.ModuleName, agg.ModuleRoot, filepath.Join(parentDir, "infrastructure", "do")),
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sConvertor.go", agg.Name)
	filePath := filepath.Join(convertorDir, fileName)

	// 生成代码
	code := g.generateCode(agg, imports)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// convertorImports 转换器的 import 路径
type convertorImports struct {
	model string
	do    string
}

// generateCode 生成转换器代码
func (g *ConvertorGenerator) generateCode(agg *metadata.AggregateMetadata, imports *convertorImports) string {
	var sb strings.Builder

	// 检查是否需要 JSON 包（有值对象且策略为 JSON）
	needJSON := false
	for _, field := range agg.Fields {
		if field.Annotations.IsValueObject && field.Annotations.Strategy == "json" {
			needJSON = true
			break
		}
	}

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package convertor\n\n")

	// 导入（使用动态计算的 import 路径）
	sb.WriteString("import (\n")
	if needJSON {
		sb.WriteString("\t\"encoding/json\"\n")
		sb.WriteString("\t\"log\"\n")
	}
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.model))
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.do))
	sb.WriteString(")\n\n")

	// ToDomain 方法
	sb.WriteString(g.generateToDomainMethod(agg))
	sb.WriteString("\n")

	// ToData 方法
	sb.WriteString(g.generateToDataMethod(agg))

	return sb.String()
}

// generateToDomainMethod 生成 ToDomain 方法（数据对象 → 领域对象）
func (g *ConvertorGenerator) generateToDomainMethod(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	doType := fmt.Sprintf("do.%sDO", agg.Name)
	domainType := fmt.Sprintf("%s.%s", agg.PackageName, agg.Name)

	// 收集值对象字段（JSON 策略）
	var jsonValueObjects []*metadata.FieldMetadata
	for _, field := range agg.Fields {
		if field.Annotations.IsValueObject && field.Annotations.Strategy == "json" {
			jsonValueObjects = append(jsonValueObjects, field)
		}
	}

	// 方法签名（函数名包含实体名称，避免同包内冲突）
	sb.WriteString(fmt.Sprintf("// %sToDomain 数据对象转领域对象\n", agg.Name))
	sb.WriteString(fmt.Sprintf("func %sToDomain(dataObj *%s) *%s {\n", agg.Name, doType, domainType))

	// nil 检查
	sb.WriteString("\tif dataObj == nil {\n")
	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t}\n\n")

	// 如果有 JSON 值对象，先进行反序列化
	if len(jsonValueObjects) > 0 {
		for _, field := range jsonValueObjects {
			fieldType := field.Type
			if field.IsPointer {
				// 指针类型的值对象
				sb.WriteString(fmt.Sprintf("\t// 反序列化 %s\n", field.Name))
				sb.WriteString(fmt.Sprintf("\tvar %s %s\n", toLowerFirst(field.Name), fieldType))
				sb.WriteString(fmt.Sprintf("\tif dataObj.%s != \"\" {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\tif err := json.Unmarshal([]byte(dataObj.%s), &%s); err != nil {\n",
					field.Name, toLowerFirst(field.Name)))
				sb.WriteString(fmt.Sprintf("\t\t\tlog.Printf(\"警告: 反序列化 %s.%s 失败: %%v\", err)\n", agg.Name, field.Name))
				sb.WriteString("\t\t}\n")
				sb.WriteString("\t}\n\n")
			} else {
				// 非指针类型的值对象
				sb.WriteString(fmt.Sprintf("\t// 反序列化 %s\n", field.Name))
				sb.WriteString(fmt.Sprintf("\tvar %s %s.%s\n", toLowerFirst(field.Name), agg.PackageName, fieldType))
				sb.WriteString(fmt.Sprintf("\tif dataObj.%s != \"\" {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\tif err := json.Unmarshal([]byte(dataObj.%s), &%s); err != nil {\n",
					field.Name, toLowerFirst(field.Name)))
				sb.WriteString(fmt.Sprintf("\t\t\tlog.Printf(\"警告: 反序列化 %s.%s 失败: %%v\", err)\n", agg.Name, field.Name))
				sb.WriteString("\t\t}\n")
				sb.WriteString("\t}\n\n")
			}
		}
	}

	// 创建领域对象
	sb.WriteString(fmt.Sprintf("\treturn &%s{\n", domainType))

	// 转换字段
	for _, field := range agg.Fields {
		// 跳过关联实体字段
		if field.Annotations.IsEntity {
			sb.WriteString(fmt.Sprintf("\t\t// %s: 关联实体，不转换\n", field.Name))
			continue
		}

		// 值对象处理
		if field.Annotations.IsValueObject {
			if field.Annotations.Strategy == "json" {
				// JSON 策略：使用前面反序列化的变量
				if field.IsPointer {
					sb.WriteString(fmt.Sprintf("\t\t%s: &%s,\n", field.Name, toLowerFirst(field.Name)))
				} else {
					sb.WriteString(fmt.Sprintf("\t\t%s: %s,\n", field.Name, toLowerFirst(field.Name)))
				}
			} else {
				// 展开策略：暂不支持，生成注释
				sb.WriteString(fmt.Sprintf("\t\t// %s: 值对象展开策略暂不支持自动转换\n", field.Name))
			}
			continue
		}

		// 简单类型直接赋值
		sb.WriteString(fmt.Sprintf("\t\t%s: dataObj.%s,\n", field.Name, field.Name))
	}

	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateToDataMethod 生成 ToData 方法（领域对象 → 数据对象）
func (g *ConvertorGenerator) generateToDataMethod(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	doType := fmt.Sprintf("do.%sDO", agg.Name)
	domainType := fmt.Sprintf("%s.%s", agg.PackageName, agg.Name)

	// 收集值对象字段（JSON 策略）
	var jsonValueObjects []*metadata.FieldMetadata
	for _, field := range agg.Fields {
		if field.Annotations.IsValueObject && field.Annotations.Strategy == "json" {
			jsonValueObjects = append(jsonValueObjects, field)
		}
	}

	// 方法签名（函数名包含实体名称，避免同包内冲突）
	sb.WriteString(fmt.Sprintf("// %sToData 领域对象转数据对象\n", agg.Name))
	sb.WriteString(fmt.Sprintf("func %sToData(domain *%s) *%s {\n", agg.Name, domainType, doType))

	// nil 检查
	sb.WriteString("\tif domain == nil {\n")
	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t}\n\n")

	// 如果有 JSON 值对象，先进行序列化
	if len(jsonValueObjects) > 0 {
		for _, field := range jsonValueObjects {
			sb.WriteString(fmt.Sprintf("\t// 序列化 %s\n", field.Name))
			sb.WriteString(fmt.Sprintf("\tvar %sJSON string\n", toLowerFirst(field.Name)))
			if field.IsPointer {
				// 指针类型需要先判空
				sb.WriteString(fmt.Sprintf("\tif domain.%s != nil {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\tif bytes, err := json.Marshal(domain.%s); err == nil {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\t\t%sJSON = string(bytes)\n", toLowerFirst(field.Name)))
				sb.WriteString("\t\t} else {\n")
				sb.WriteString(fmt.Sprintf("\t\t\tlog.Printf(\"警告: 序列化 %s.%s 失败: %%v\", err)\n", agg.Name, field.Name))
				sb.WriteString("\t\t}\n")
				sb.WriteString("\t}\n\n")
			} else {
				// 非指针类型直接序列化
				sb.WriteString(fmt.Sprintf("\tif bytes, err := json.Marshal(domain.%s); err == nil {\n", field.Name))
				sb.WriteString(fmt.Sprintf("\t\t%sJSON = string(bytes)\n", toLowerFirst(field.Name)))
				sb.WriteString("\t} else {\n")
				sb.WriteString(fmt.Sprintf("\t\tlog.Printf(\"警告: 序列化 %s.%s 失败: %%v\", err)\n", agg.Name, field.Name))
				sb.WriteString("\t}\n\n")
			}
		}
	}

	// 创建数据对象
	sb.WriteString(fmt.Sprintf("\treturn &%s{\n", doType))

	// 转换字段
	for _, field := range agg.Fields {
		// 跳过关联实体字段
		if field.Annotations.IsEntity {
			sb.WriteString(fmt.Sprintf("\t\t// %s: 关联实体，不转换\n", field.Name))
			continue
		}

		// 值对象处理
		if field.Annotations.IsValueObject {
			if field.Annotations.Strategy == "json" {
				// JSON 策略：使用前面序列化的变量
				sb.WriteString(fmt.Sprintf("\t\t%s: %sJSON,\n", field.Name, toLowerFirst(field.Name)))
			} else {
				// 展开策略：暂不支持，生成注释
				sb.WriteString(fmt.Sprintf("\t\t// %s: 值对象展开策略暂不支持自动转换\n", field.Name))
			}
			continue
		}

		// 简单类型直接赋值
		sb.WriteString(fmt.Sprintf("\t\t%s: domain.%s,\n", field.Name, field.Name))
	}

	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}
