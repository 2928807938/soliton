package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// DOGenerator 数据对象（DO）生成器
//
// 生成用于数据库持久化的数据对象，与领域对象的区别：
//  1. 只包含需要持久化的字段
//  2. 关联实体字段不存储（只存储外键ID）
//  3. 值对象可以展开为多个字段或序列化为JSON
//  4. 添加 GORM 标签用于数据库映射
//
// 生成文件：infrastructure/persistence/do/{AggregateName}DO.go
type DOGenerator struct{}

// NewDOGenerator 创建 DO 生成器
func NewDOGenerator() *DOGenerator {
	return &DOGenerator{}
}

// Generate 为聚合根生成数据对象
func (g *DOGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 创建输出目录
	doDir := filepath.Join(outputDir, "infrastructure", "persistence", "do")
	if err := os.MkdirAll(doDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sDO.go", agg.Name)
	filePath := filepath.Join(doDir, fileName)

	// 生成代码
	code := g.generateCode(agg)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// generateCode 生成 DO 代码
func (g *DOGenerator) generateCode(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package do\n\n")

	// 导入
	needTimeImport := false
	for _, field := range agg.Fields {
		if field.Type == "time.Time" || field.Type == "*time.Time" {
			needTimeImport = true
			break
		}
	}

	if needTimeImport {
		sb.WriteString("import \"time\"\n\n")
	}

	// 结构体定义
	sb.WriteString(fmt.Sprintf("// %sDO %s 数据对象\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("type %sDO struct {\n", agg.Name))

	// 生成字段
	for _, field := range agg.Fields {
		// 跳过关联实体字段（+soliton:entity）
		if field.Annotations.IsEntity {
			continue
		}

		// 生成字段
		fieldCode := g.generateField(field, agg)
		if fieldCode != "" {
			sb.WriteString(fieldCode)
		}
	}

	sb.WriteString("}\n\n")

	// TableName 方法
	tableName := toSnakeCase(agg.Name) + "s"
	sb.WriteString(fmt.Sprintf("// TableName 指定表名\n"))
	sb.WriteString(fmt.Sprintf("func (%sDO) TableName() string {\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\treturn \"%s\"\n", tableName))
	sb.WriteString("}\n")

	return sb.String()
}

// generateField 生成单个字段
func (g *DOGenerator) generateField(field *metadata.FieldMetadata, agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	// 字段注释
	if field.Annotations.IsRef {
		sb.WriteString(fmt.Sprintf("\t%s %s `gorm:\"column:%s",
			field.Name, field.Type, field.DBTag))
	} else if field.Annotations.IsValueObject {
		// 值对象处理
		return g.generateValueObjectField(field)
	} else {
		// 普通字段
		fieldType := field.Type
		if field.IsPointer {
			fieldType = "*" + fieldType
		}

		sb.WriteString(fmt.Sprintf("\t%s %s `gorm:\"column:%s",
			field.Name, fieldType, field.DBTag))
	}

	// 添加 GORM 标签
	tags := g.generateGORMTags(field, agg)
	if tags != "" {
		sb.WriteString(tags)
	}

	sb.WriteString("\"`\n")

	return sb.String()
}

// generateGORMTags 生成 GORM 标签
func (g *DOGenerator) generateGORMTags(field *metadata.FieldMetadata, agg *metadata.AggregateMetadata) string {
	var tags []string

	// 主键
	if agg.IDField != nil && field.Name == agg.IDField.Name {
		tags = append(tags, "primaryKey")
		tags = append(tags, "autoIncrement")
	}

	// 唯一索引
	if field.Annotations.IsUnique {
		tags = append(tags, fmt.Sprintf("uniqueIndex:idx_%s", field.DBTag))
	}

	// 普通索引
	if field.Annotations.IsIndex {
		tags = append(tags, fmt.Sprintf("index:idx_%s", field.DBTag))
	}

	// 外键索引
	if field.Annotations.IsRef {
		tags = append(tags, fmt.Sprintf("index:idx_%s", field.DBTag))
	}

	// 必填字段
	if field.Annotations.IsRequired {
		tags = append(tags, "not null")
	}

	// 软删除字段
	if field.Name == "DeletedAt" {
		tags = append(tags, "index:idx_deleted_at")
	}

	if len(tags) == 0 {
		return ""
	}

	return ";" + strings.Join(tags, ";")
}

// generateValueObjectField 生成值对象字段
func (g *DOGenerator) generateValueObjectField(field *metadata.FieldMetadata) string {
	// 如果策略是 JSON，则序列化为字符串
	if field.Annotations.Strategy == "json" {
		return fmt.Sprintf("\t%s string `gorm:\"column:%s;type:text\"`\n",
			field.Name, field.DBTag)
	}

	// 默认策略：展开为多个字段
	// 这里简化处理，实际应该递归解析值对象的字段
	// 暂时返回空，表示跳过
	return ""
}

// toSnakeCase 转换为蛇形命名
func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}
