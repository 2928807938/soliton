package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// RepositoryImplGenerator 仓储实现生成器
//
// 生成嵌入 BaseRepository[T, D] 的具体仓储实现，并实现扩展方法。
//
// 生成文件：infrastructure/persistence/{AggregateName}RepositoryImpl.go
type RepositoryImplGenerator struct{}

// NewRepositoryImplGenerator 创建仓储实现生成器
func NewRepositoryImplGenerator() *RepositoryImplGenerator {
	return &RepositoryImplGenerator{}
}

// Generate 为聚合根生成仓储实现
func (g *RepositoryImplGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 获取绝对路径
	absOutputDir, _ := filepath.Abs(outputDir)
	parentDir := filepath.Dir(absOutputDir)

	// 创建输出目录（infrastructure 与 domain 平级）
	implDir := filepath.Join(parentDir, "infrastructure", "repository")
	if err := os.MkdirAll(implDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 计算各个依赖的 import 路径
	imports := &repoImplImports{
		model:      agg.ImportPath,
		repository: calculateImportPath(agg.ModuleName, agg.ModuleRoot, filepath.Join(absOutputDir, "repository")),
		convertor:  calculateImportPath(agg.ModuleName, agg.ModuleRoot, filepath.Join(parentDir, "infrastructure", "convertor")),
		do:         calculateImportPath(agg.ModuleName, agg.ModuleRoot, filepath.Join(parentDir, "infrastructure", "do")),
		query:      calculateImportPath(agg.ModuleName, agg.ModuleRoot, filepath.Join(parentDir, "infrastructure", "query")),
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sRepositoryImpl.go", agg.Name)
	filePath := filepath.Join(implDir, fileName)

	// 生成代码
	code := g.generateCode(agg, imports)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// repoImplImports 仓储实现的 import 路径
type repoImplImports struct {
	model      string
	repository string
	convertor  string
	do         string
	query      string
}

// generateCode 生成仓储实现代码
func (g *RepositoryImplGenerator) generateCode(agg *metadata.AggregateMetadata, imports *repoImplImports) string {
	var sb strings.Builder

	// 检查是否需要 errors 包（有 unique 字段时需要）
	needErrors := false
	for _, field := range agg.Fields {
		if field.Annotations.IsUnique {
			needErrors = true
			break
		}
	}

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package repository\n\n")

	// 导入（使用动态计算的 import 路径）
	sb.WriteString("import (\n")
	sb.WriteString("\t\"context\"\n")
	if needErrors {
		sb.WriteString("\t\"errors\"\n")
	}
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.model))
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.repository))
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.convertor))
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.do))
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", imports.query))
	sb.WriteString("\t\"soliton/pkg/framework\"\n")
	sb.WriteString("\t\"gorm.io/gorm\"\n")
	sb.WriteString(")\n\n")

	// 结构体定义
	sb.WriteString(fmt.Sprintf("// %sRepositoryImpl %s 仓储实现\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("type %sRepositoryImpl struct {\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\tframework.BaseRepository[*%s.%s, do.%sDO]\n", agg.PackageName, agg.Name, agg.Name))
	sb.WriteString("}\n\n")

	// 构造函数
	sb.WriteString(g.generateConstructor(agg))
	sb.WriteString("\n")

	// 生成扩展方法实现
	sb.WriteString(g.generateExtendMethodsImpl(agg))

	// 接口实现检查
	sb.WriteString(fmt.Sprintf("// 确保实现了接口\n"))
	sb.WriteString(fmt.Sprintf("var _ repository.%sRepository = (*%sRepositoryImpl)(nil)\n",
		agg.Name, agg.Name))

	return sb.String()
}

// generateConstructor 生成构造函数
func (g *RepositoryImplGenerator) generateConstructor(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// New%sRepository 创建 %s 仓储实例\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("func New%sRepository(db *gorm.DB) *%sRepositoryImpl {\n",
		agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("\treturn &%sRepositoryImpl{\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\t\tBaseRepository: *framework.NewBaseRepository[*%s.%s, do.%sDO](\n",
		agg.PackageName, agg.Name, agg.Name))
	sb.WriteString("\t\t\tdb,\n")
	sb.WriteString(fmt.Sprintf("\t\t\tconvertor.%sToData,\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\t\t\tconvertor.%sToDomain,\n", agg.Name))
	sb.WriteString("\t\t),\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateExtendMethodsImpl 生成扩展方法实现
func (g *RepositoryImplGenerator) generateExtendMethodsImpl(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder
	// 记录已生成的方法名，避免重复
	generatedMethods := make(map[string]bool)

	for _, field := range agg.Fields {
		// 跳过 ID 字段和关联实体字段
		if (agg.IDField != nil && field.Name == agg.IDField.Name) || field.Annotations.IsEntity {
			continue
		}

		methodName := fmt.Sprintf("GetBy%s", field.Name)

		// unique 字段实现
		if field.Annotations.IsUnique {
			if !generatedMethods[methodName] {
				sb.WriteString(g.generateGetByUniqueMethod(agg, field))
				sb.WriteString("\n")
				generatedMethods[methodName] = true
			}
		}

		// index 或 ref 字段实现（避免重复生成）
		if field.Annotations.IsIndex || field.Annotations.IsRef {
			if !generatedMethods[methodName] {
				sb.WriteString(g.generateGetByIndexMethod(agg, field))
				sb.WriteString("\n")
				generatedMethods[methodName] = true
			}
		}
	}

	return sb.String()
}

// generateGetByUniqueMethod 生成唯一字段查询方法
func (g *RepositoryImplGenerator) generateGetByUniqueMethod(agg *metadata.AggregateMetadata, field *metadata.FieldMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// GetBy%s 根据 %s 查询（唯一）\n", field.Name, field.Name))
	sb.WriteString(fmt.Sprintf("func (%s *%sRepositoryImpl) GetBy%s(ctx context.Context, %s %s) (*%s.%s, error) {\n",
		receiver, agg.Name, field.Name, toLowerFirst(field.Name), field.Type, agg.PackageName, agg.Name))
	sb.WriteString(fmt.Sprintf("\tvar dataObj do.%sDO\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\tcond := query.%s.%s.Eq(%s)\n", agg.Name, field.Name, toLowerFirst(field.Name)))
	sb.WriteString(fmt.Sprintf("\tsql, args := cond.Build()\n"))
	sb.WriteString(fmt.Sprintf("\terr := %s.BaseRepository.DB().WithContext(ctx).Where(sql, args...).First(&dataObj).Error\n", receiver))
	sb.WriteString("\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n")
	sb.WriteString("\t\t\treturn nil, errors.New(\"记录不存在\")\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t\treturn nil, err\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("\treturn convertor.%sToDomain(&dataObj), nil\n", agg.Name))
	sb.WriteString("}\n")

	return sb.String()
}

// generateGetByIndexMethod 生成索引字段查询方法
func (g *RepositoryImplGenerator) generateGetByIndexMethod(agg *metadata.AggregateMetadata, field *metadata.FieldMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// GetBy%s 根据 %s 查询（索引）\n", field.Name, field.Name))
	sb.WriteString(fmt.Sprintf("func (%s *%sRepositoryImpl) GetBy%s(ctx context.Context, %s %s) ([]*%s.%s, error) {\n",
		receiver, agg.Name, field.Name, toLowerFirst(field.Name), field.Type, agg.PackageName, agg.Name))
	sb.WriteString(fmt.Sprintf("\tvar dataObjs []do.%sDO\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\tcond := query.%s.%s.Eq(%s)\n", agg.Name, field.Name, toLowerFirst(field.Name)))
	sb.WriteString(fmt.Sprintf("\tsql, args := cond.Build()\n"))
	sb.WriteString(fmt.Sprintf("\terr := %s.BaseRepository.DB().WithContext(ctx).Where(sql, args...).Find(&dataObjs).Error\n", receiver))
	sb.WriteString("\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\treturn nil, err\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("\tresult := make([]*%s.%s, len(dataObjs))\n", agg.PackageName, agg.Name))
	sb.WriteString("\tfor i, dataObj := range dataObjs {\n")
	sb.WriteString(fmt.Sprintf("\t\tresult[i] = convertor.%sToDomain(&dataObj)\n", agg.Name))
	sb.WriteString("\t}\n")
	sb.WriteString("\n")
	sb.WriteString("\treturn result, nil\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateGetByRefMethod 生成外键字段查询方法
func (g *RepositoryImplGenerator) generateGetByRefMethod(agg *metadata.AggregateMetadata, field *metadata.FieldMetadata) string {
	// ref 字段和 index 字段的实现逻辑相同
	return g.generateGetByIndexMethod(agg, field)
}
