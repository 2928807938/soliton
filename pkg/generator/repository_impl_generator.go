package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// RepositoryImplGenerator 仓储实现生成器
//
// 生成嵌入 BaseRepository[T, D] 的具体仓储实现，并实现扩展方法。
//
// 生成文件：infrastructure/persistence/{AggregateName}RepositoryImpl.go
type RepositoryImplGenerator struct{}

// NewRepositoryImplGenerator 创建仓储实现生成器
func NewRepositoryImplGenerator() *RepositoryImplGenerator {
	return &RepositoryImplGenerator{}
}

// Generate 为聚合根生成仓储实现
func (g *RepositoryImplGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 创建输出目录
	implDir := filepath.Join(outputDir, "infrastructure", "persistence")
	if err := os.MkdirAll(implDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sRepositoryImpl.go", agg.Name)
	filePath := filepath.Join(implDir, fileName)

	// 生成代码
	code := g.generateCode(agg)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// generateCode 生成仓储实现代码
func (g *RepositoryImplGenerator) generateCode(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package persistence\n\n")

	// 导入
	sb.WriteString("import (\n")
	sb.WriteString("\t\"context\"\n")
	sb.WriteString("\t\"errors\"\n")
	sb.WriteString("\t\"domain/model\"\n")
	sb.WriteString("\t\"domain/repository\"\n")
	sb.WriteString("\t\"infrastructure/persistence/convertor\"\n")
	sb.WriteString("\t\"infrastructure/persistence/do\"\n")
	sb.WriteString("\t\"soliton/pkg/framework\"\n")
	sb.WriteString("\t\"gorm.io/gorm\"\n")
	sb.WriteString(")\n\n")

	// 结构体定义
	sb.WriteString(fmt.Sprintf("// %sRepositoryImpl %s 仓储实现\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("type %sRepositoryImpl struct {\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\tframework.BaseRepository[model.%s, do.%sDO]\n", agg.Name, agg.Name))
	sb.WriteString("}\n\n")

	// 构造函数
	sb.WriteString(g.generateConstructor(agg))
	sb.WriteString("\n")

	// 生成扩展方法实现
	sb.WriteString(g.generateExtendMethodsImpl(agg))

	// 接口实现检查
	sb.WriteString(fmt.Sprintf("// 确保实现了接口\n"))
	sb.WriteString(fmt.Sprintf("var _ repository.%sRepository = (*%sRepositoryImpl)(nil)\n",
		agg.Name, agg.Name))

	return sb.String()
}

// generateConstructor 生成构造函数
func (g *RepositoryImplGenerator) generateConstructor(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// New%sRepository 创建 %s 仓储实例\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("func New%sRepository(db *gorm.DB) *%sRepositoryImpl {\n",
		agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("\treturn &%sRepositoryImpl{\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\t\tBaseRepository: *framework.NewBaseRepository[model.%s, do.%sDO](\n",
		agg.Name, agg.Name))
	sb.WriteString("\t\t\tdb,\n")
	sb.WriteString("\t\t\tconvertor.ToData,\n")
	sb.WriteString("\t\t\tconvertor.ToDomain,\n")
	sb.WriteString("\t\t),\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateExtendMethodsImpl 生成扩展方法实现
func (g *RepositoryImplGenerator) generateExtendMethodsImpl(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	for _, field := range agg.Fields {
		// 跳过 ID 字段和关联实体字段
		if (agg.IDField != nil && field.Name == agg.IDField.Name) || field.Annotations.IsEntity {
			continue
		}

		// unique 字段实现
		if field.Annotations.IsUnique {
			sb.WriteString(g.generateGetByUniqueMethod(agg, field))
			sb.WriteString("\n")
		}

		// index 字段实现
		if field.Annotations.IsIndex {
			sb.WriteString(g.generateGetByIndexMethod(agg, field))
			sb.WriteString("\n")
		}

		// ref 字段实现
		if field.Annotations.IsRef {
			sb.WriteString(g.generateGetByRefMethod(agg, field))
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// generateGetByUniqueMethod 生成唯一字段查询方法
func (g *RepositoryImplGenerator) generateGetByUniqueMethod(agg *metadata.AggregateMetadata, field *metadata.FieldMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// GetBy%s 根据 %s 查询（唯一）\n", field.Name, field.Name))
	sb.WriteString(fmt.Sprintf("func (%s *%sRepositoryImpl) GetBy%s(ctx context.Context, %s %s) (*model.%s, error) {\n",
		receiver, agg.Name, field.Name, toLowerFirst(field.Name), field.Type, agg.Name))
	sb.WriteString(fmt.Sprintf("\tvar dataObj do.%sDO\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\terr := %s.BaseRepository.DB().WithContext(ctx).Where(\"%s = ?\", %s).First(&dataObj).Error\n",
		receiver, field.DBTag, toLowerFirst(field.Name)))
	sb.WriteString("\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n")
	sb.WriteString("\t\t\treturn nil, errors.New(\"记录不存在\")\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t\treturn nil, err\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\n")
	sb.WriteString("\treturn convertor.ToDomain(&dataObj), nil\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateGetByIndexMethod 生成索引字段查询方法
func (g *RepositoryImplGenerator) generateGetByIndexMethod(agg *metadata.AggregateMetadata, field *metadata.FieldMetadata) string {
	var sb strings.Builder

	receiver := strings.ToLower(string(agg.Name[0]))

	sb.WriteString(fmt.Sprintf("// GetBy%s 根据 %s 查询（索引）\n", field.Name, field.Name))
	sb.WriteString(fmt.Sprintf("func (%s *%sRepositoryImpl) GetBy%s(ctx context.Context, %s %s) ([]*model.%s, error) {\n",
		receiver, agg.Name, field.Name, toLowerFirst(field.Name), field.Type, agg.Name))
	sb.WriteString(fmt.Sprintf("\tvar dataObjs []do.%sDO\n", agg.Name))
	sb.WriteString(fmt.Sprintf("\terr := %s.BaseRepository.DB().WithContext(ctx).Where(\"%s = ?\", %s).Find(&dataObjs).Error\n",
		receiver, field.DBTag, toLowerFirst(field.Name)))
	sb.WriteString("\n")
	sb.WriteString("\tif err != nil {\n")
	sb.WriteString("\t\treturn nil, err\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("\tresult := make([]*model.%s, len(dataObjs))\n", agg.Name))
	sb.WriteString("\tfor i, dataObj := range dataObjs {\n")
	sb.WriteString("\t\tresult[i] = convertor.ToDomain(&dataObj)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\n")
	sb.WriteString("\treturn result, nil\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateGetByRefMethod 生成外键字段查询方法
func (g *RepositoryImplGenerator) generateGetByRefMethod(agg *metadata.AggregateMetadata, field *metadata.FieldMetadata) string {
	// ref 字段和 index 字段的实现逻辑相同
	return g.generateGetByIndexMethod(agg, field)
}
