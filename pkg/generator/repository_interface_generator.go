package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// RepositoryInterfaceGenerator 仓储接口生成器
//
// 生成继承泛型 Repository[T] 的具体仓储接口，并添加扩展方法。
//
// 扩展方法生成规则（根据字段注解）：
//   - +soliton:unique → GetByXxx(ctx, xxx) (*T, error)  返回单个对象
//   - +soliton:index  → GetByXxx(ctx, xxx) ([]*T, error) 返回列表
//   - +soliton:ref    → GetByXxx(ctx, xxx) ([]*T, error) 返回列表
//
// 生成文件：domain/repository/{AggregateName}Repository.go
type RepositoryInterfaceGenerator struct{}

// NewRepositoryInterfaceGenerator 创建仓储接口生成器
func NewRepositoryInterfaceGenerator() *RepositoryInterfaceGenerator {
	return &RepositoryInterfaceGenerator{}
}

// Generate 为聚合根生成仓储接口
func (g *RepositoryInterfaceGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 创建输出目录
	repoDir := filepath.Join(outputDir, "repository")
	if err := os.MkdirAll(repoDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sRepository.go", agg.Name)
	filePath := filepath.Join(repoDir, fileName)

	// 生成代码
	code := g.generateCode(agg)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// generateCode 生成仓储接口代码
func (g *RepositoryInterfaceGenerator) generateCode(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package repository\n\n")

	// 导入
	sb.WriteString("import (\n")
	sb.WriteString("\t\"context\"\n")
	sb.WriteString("\t\"model\"\n")
	sb.WriteString("\t\"soliton/pkg/framework\"\n")
	sb.WriteString(")\n\n")

	// 接口定义
	sb.WriteString(fmt.Sprintf("// %sRepository %s 仓储接口\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("type %sRepository interface {\n", agg.Name))

	// 继承泛型接口
	sb.WriteString(fmt.Sprintf("\tframework.Repository[model.%s]\n", agg.Name))

	// 生成扩展方法
	extendMethods := g.generateExtendMethods(agg)
	if extendMethods != "" {
		sb.WriteString("\n")
		sb.WriteString(extendMethods)
	}

	sb.WriteString("}\n")

	return sb.String()
}

// generateExtendMethods 生成扩展方法
func (g *RepositoryInterfaceGenerator) generateExtendMethods(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	for _, field := range agg.Fields {
		// 跳过 ID 字段和关联实体字段
		if (agg.IDField != nil && field.Name == agg.IDField.Name) || field.Annotations.IsEntity {
			continue
		}

		// unique 字段生成 GetByXxx 方法（返回单个对象）
		if field.Annotations.IsUnique {
			sb.WriteString(fmt.Sprintf("\t// GetBy%s 根据 %s 查询（唯一）\n",
				field.Name, field.Name))
			sb.WriteString(fmt.Sprintf("\tGetBy%s(ctx context.Context, %s %s) (*model.%s, error)\n",
				field.Name, toLowerFirst(field.Name), field.Type, agg.Name))
			sb.WriteString("\n")
		}

		// index 字段生成 GetByXxx 方法（返回列表）
		if field.Annotations.IsIndex {
			sb.WriteString(fmt.Sprintf("\t// GetBy%s 根据 %s 查询（索引）\n",
				field.Name, field.Name))
			sb.WriteString(fmt.Sprintf("\tGetBy%s(ctx context.Context, %s %s) ([]*model.%s, error)\n",
				field.Name, toLowerFirst(field.Name), field.Type, agg.Name))
			sb.WriteString("\n")
		}

		// ref 字段生成 GetByXxx 方法（返回列表）
		if field.Annotations.IsRef {
			sb.WriteString(fmt.Sprintf("\t// GetBy%s 根据 %s 查询（外键）\n",
				field.Name, field.Name))
			sb.WriteString(fmt.Sprintf("\tGetBy%s(ctx context.Context, %s %s) ([]*model.%s, error)\n",
				field.Name, toLowerFirst(field.Name), field.Type, agg.Name))
			sb.WriteString("\n")
		}
	}

	return sb.String()
}
