package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"soliton/pkg/metadata"
	"strings"
)

// RepositoryInterfaceGenerator 仓储接口生成器
//
// 生成继承泛型 Repository[T] 的具体仓储接口，并添加扩展方法。
//
// 扩展方法生成规则（根据字段注解）：
//   - +soliton:unique → GetByXxx(ctx, xxx) (*T, error)  返回单个对象
//   - +soliton:index  → GetByXxx(ctx, xxx) ([]*T, error) 返回列表
//   - +soliton:ref    → GetByXxx(ctx, xxx) ([]*T, error) 返回列表
//
// 生成文件：domain/repository/{AggregateName}Repository.go
type RepositoryInterfaceGenerator struct{}

// NewRepositoryInterfaceGenerator 创建仓储接口生成器
func NewRepositoryInterfaceGenerator() *RepositoryInterfaceGenerator {
	return &RepositoryInterfaceGenerator{}
}

// Generate 为聚合根生成仓储接口
func (g *RepositoryInterfaceGenerator) Generate(agg *metadata.AggregateMetadata, outputDir string) error {
	// 创建输出目录
	repoDir := filepath.Join(outputDir, "repository")
	if err := os.MkdirAll(repoDir, 0755); err != nil {
		return fmt.Errorf("创建输出目录失败: %w", err)
	}

	// 生成文件路径
	fileName := fmt.Sprintf("%sRepository.go", agg.Name)
	filePath := filepath.Join(repoDir, fileName)

	// 生成代码
	code := g.generateCode(agg)

	// 写入文件
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}

	return nil
}

// generateCode 生成仓储接口代码
func (g *RepositoryInterfaceGenerator) generateCode(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder

	// 文件头
	sb.WriteString("// Code generated by soliton. DO NOT EDIT.\n\n")
	sb.WriteString("package repository\n\n")

	// 导入（使用实际的领域模型 import 路径）
	sb.WriteString("import (\n")
	sb.WriteString("\t\"context\"\n")
	sb.WriteString(fmt.Sprintf("\t\"%s\"\n", agg.ImportPath))
	sb.WriteString("\t\"soliton/pkg/framework\"\n")
	sb.WriteString(")\n\n")

	// 接口定义
	sb.WriteString(fmt.Sprintf("// %sRepository %s 仓储接口\n", agg.Name, agg.Name))
	sb.WriteString(fmt.Sprintf("type %sRepository interface {\n", agg.Name))

	// 继承泛型接口（使用指针类型，因为 Entity 接口方法定义在指针接收器上）
	sb.WriteString(fmt.Sprintf("\tframework.Repository[*%s.%s]\n", agg.PackageName, agg.Name))

	// 生成扩展方法
	extendMethods := g.generateExtendMethods(agg)
	if extendMethods != "" {
		sb.WriteString("\n")
		sb.WriteString(extendMethods)
	}

	sb.WriteString("}\n")

	return sb.String()
}

// generateExtendMethods 生成扩展方法
func (g *RepositoryInterfaceGenerator) generateExtendMethods(agg *metadata.AggregateMetadata) string {
	var sb strings.Builder
	// 记录已生成的方法名，避免重复
	generatedMethods := make(map[string]bool)

	for _, field := range agg.Fields {
		// 跳过 ID 字段和关联实体字段
		if (agg.IDField != nil && field.Name == agg.IDField.Name) || field.Annotations.IsEntity {
			continue
		}

		methodName := fmt.Sprintf("GetBy%s", field.Name)

		// unique 字段生成 GetByXxx 方法（返回单个对象）
		if field.Annotations.IsUnique {
			if !generatedMethods[methodName] {
				sb.WriteString(fmt.Sprintf("\t// GetBy%s 根据 %s 查询（唯一）\n",
					field.Name, field.Name))
				sb.WriteString(fmt.Sprintf("\tGetBy%s(ctx context.Context, %s %s) (*%s.%s, error)\n",
					field.Name, toLowerFirst(field.Name), field.Type, agg.PackageName, agg.Name))
				sb.WriteString("\n")
				generatedMethods[methodName] = true
			}
		}

		// index 和 ref 字段生成 GetByXxx 方法（返回列表）
		// 如果同时有 index 和 ref 注解，只生成一个方法
		if field.Annotations.IsIndex || field.Annotations.IsRef {
			if !generatedMethods[methodName] {
				// 构建注释说明
				var comments []string
				if field.Annotations.IsIndex {
					comments = append(comments, "索引")
				}
				if field.Annotations.IsRef {
					comments = append(comments, "外键")
				}
				comment := strings.Join(comments, "/")

				sb.WriteString(fmt.Sprintf("\t// GetBy%s 根据 %s 查询（%s）\n",
					field.Name, field.Name, comment))
				sb.WriteString(fmt.Sprintf("\tGetBy%s(ctx context.Context, %s %s) ([]*%s.%s, error)\n",
					field.Name, toLowerFirst(field.Name), field.Type, agg.PackageName, agg.Name))
				sb.WriteString("\n")
				generatedMethods[methodName] = true
			}
		}
	}

	return sb.String()
}
